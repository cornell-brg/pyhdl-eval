#=========================================================================
# Makefile
#=========================================================================

#-------------------------------------------------------------------------
# Basic setup
#-------------------------------------------------------------------------

# Remove all default implicit rules since they can cause subtle bugs
# and they just make things run slower
.SUFFIXES:
% : %,v
% : RCS/%,v
% : RCS/%
% : s.%
% : SCCS/s.%

# Default is to build the prereqs of the all target (defined at bottom)
default : all
.PHONY : default

src_dir      := @srcdir@
scripts_dir  := $(src_dir)/scripts

#-------------------------------------------------------------------------
# Programs
#-------------------------------------------------------------------------

GENERATE=$(scripts_dir)/generate

GENERATE_FLAGS = "--model=@model@"

examples=@examples@
ifneq ($(examples),no)
  GENERATE_FLAGS += "--examples=$(examples)"
endif

rules=@rules@
ifeq ($(rules),yes)
  GENERATE_FLAGS += "--rules"
endif

IVERILOG_FLAGS=-Wall -Winfloop -Wno-timescale -g2012
IVERILOG_COMPILE=@IVERILOG@ $(IVERILOG_FLAGS)

#-------------------------------------------------------------------------
# Dataset
#-------------------------------------------------------------------------

dataset_dir = @dataset_dir@
VPATH = ${dataset_dir}
include problems.mk
include samples.mk

# Define prompt files

problem_prompts := $(patsubst %, %_prompt.txt, $(problems))

#-------------------------------------------------------------------------
# Progress indicator
#-------------------------------------------------------------------------
# Here is some neat code that enables a more compact output with a
# progress indication:
#
#  https://stackoverflow.com/questions/451413
#

REDIRECT_LOG= &>
REDIRECT_APPEND_LOG= &>>
VERBOSE:=0
QUIET=@
ifeq ($(VERBOSE),1)
  QUIET=
  REDIRECT_LOG= 2>&1 | tee
  REDIRECT_APPEND_LOG= 2>&1 | tee -a
endif

ifndef ECHO

# Do a dry run of make with with given targets and count number of
# times we see HIT_MARK which shows up for every instance of ECHO

HIT_TOTAL != $(MAKE) $(MAKECMDGOALS) --dry-run ECHO="HIT_MARK" | grep -c "HIT_MARK"

# Create a counter which will increment every instance of ECHO

HIT_COUNT = $(eval HIT_N != expr $(HIT_N) + 1)$(HIT_N)

# Create the output counter

ECHO = $(scripts_dir)/echo-progress \
         --nsteps=$(HIT_TOTAL) --stepno=$(HIT_COUNT) --verbose=$(VERBOSE)

endif

#-------------------------------------------------------------------------
# Template for per-problem rules
#-------------------------------------------------------------------------
# The template is instantiated for each of the problems.
#
# Arguments:
#  $(1) : real problem name (ie with underscores, no dashes)
#

define problem_template

# Figure out number of samples for this problem

sample_num_strs != seq --format "%02g" 1 $$($(1)_num_samples)

#-------------------------------------------------------------------------
# Generate verilog samples
#-------------------------------------------------------------------------

$(1)_sv_samples       := $$(patsubst %, $(1)/$(1)_sample%.v, $$(sample_num_strs))
$(1)_sv_generate_logs := $$(patsubst %, $(1)/$(1)_sample%-sv-generate.log, $$(sample_num_strs))

$$($(1)_sv_samples) : %.v : $(1)_prompt.txt
	@$$(ECHO) Generating $$(notdir $$@) verilog
	$$(QUIET) mkdir -p $(1)
	$$(QUIET) $$(GENERATE) $$(GENERATE_FLAGS) --lang=verilog --verbose \
              --output $$@ $$< \
              $(REDIRECT_LOG) $$*-sv-generate.log

$(1)-sv-generate : $$($(1)_sv_samples)

pregen_files += $$($(1)_sv_samples)
pregen_files += $$($(1)_sv_generate_logs)

sv_generate_targets += $$($(1)_sv_samples)

$(1)-sv-generate-clean :
	rm -rf $$($(1)_sv_samples)
	rm -rf $$($(1)_sv_generate_logs)

sv_generate_clean_targets += $(1)-sv-generate-clean

#-------------------------------------------------------------------------
# Test verilog samples
#-------------------------------------------------------------------------

$(1)_sv_iv_test_bins = \
  $$(patsubst %.v, %, $$($(1)_sv_samples))

$(1)_sv_iv_test_logs = \
  $$(patsubst %.v, %-sv-iv-test.log, $$($(1)_sv_samples))

$$($(1)_sv_iv_test_logs) : %-sv-iv-test.log : %.v $(1)_test.v $(1)_ref.v
	@$$(ECHO)  Testing $$(notdir $$*) with iverilog
	-$$(QUIET) $(IVERILOG_COMPILE) -s Top -I $(dataset_dir) -o $$* $$^ \
               $(REDIRECT_LOG) $$*-sv-iv-test.log
	-$$(QUIET) timeout 30 ./$$* +test-case=-1 $(REDIRECT_APPEND_LOG) $$@; \
             if [[ $$$${PIPESTATUS[0]} == 124 ]]; then    \
               echo "TIMEOUT" $(REDIRECT_APPEND_LOG) $$@; \
             fi

$(1)-sv-iv-test : $$($(1)_sv_iv_test_logs)

sv_iv_test_targets += $$($(1)_sv_iv_test_logs)

$(1)-sv-iv-test-clean :
	rm -rf $$($(1)_sv_iv_test_bins)
	rm -rf $$($(1)_sv_iv_test_logs)

sv_iv_test_clean_targets += $(1)-sv-iv-test-clean

#-------------------------------------------------------------------------
# Test verilog samples with PyMTL/Verilator
#-------------------------------------------------------------------------

# $(1)_sv_vr_test_logs = \
#   $$(patsubst %.v, %-sv-vr-test.log, $$($(1)_sv_samples))
#  
# $$($(1)_sv_vr_test_logs) : %-sv-vr-test.log : $(1)_test.py %.v
#  	@$$(ECHO)  Testing $$(notdir $$*) with pymtl/verilator
#  	-$$(QUIET) cd $(1); pytest ../$$< -s --verbose --tb=short \
#                --verilog=$$(notdir $$*).v \
#                $(REDIRECT_LOG) $$(notdir $$*)-sv-vr-test.log
#  
# $(1)-sv-vr-test : $$($(1)_sv_vr_test_logs)
#  
# sv_vr_test_targets += $$($(1)_sv_vr_test_logs)
#  
# $(1)-sv-vr-test-clean :
#  	rm -rf $$($(1)_sv_vr_test_logs)
#  
# sv_vr_test_clean_targets += $(1)-sv-vr-test-clean

#-------------------------------------------------------------------------
# Generate pymtl samples
#-------------------------------------------------------------------------

$(1)_py_samples       := $$(patsubst %, $(1)/$(1)_sample%.py, $$(sample_num_strs))
$(1)_py_generate_logs := $$(patsubst %, $(1)/$(1)_sample%-py-generate.log, $$(sample_num_strs))

$$($(1)_py_samples) : %.py : $(1)_prompt.txt
	@$$(ECHO) Generating $$(notdir $$@) pymtl
	$$(QUIET) mkdir -p $(1)
	$$(QUIET) $$(GENERATE) $$(GENERATE_FLAGS) --lang=pymtl --verbose \
              --output $$@ $$< \
              $(REDIRECT_LOG) $$*-py-generate.log

$(1)-py-generate : $$($(1)_py_samples)

pregen_files += $$($(1)_py_samples)
pregen_files += $$($(1)_py_generate_logs)

py_generate_targets += $$($(1)_py_samples)

$(1)-py-generate-clean :
	rm -rf $$($(1)_py_samples)
	rm -rf $$($(1)_py_generate_logs)

py_generate_clean_targets += $(1)-py-generate-clean

#-------------------------------------------------------------------------
# Test pymtl samples with pymtl
#-------------------------------------------------------------------------

$(1)_py_py_test_logs = \
  $$(patsubst %.py, %-py-py-test.log, $$($(1)_py_samples))

$$($(1)_py_py_test_logs) : %-py-py-test.log : $(1)_test.py %.py
	@$$(ECHO)  Testing $$(notdir $$*) with pymtl
	-$$(QUIET) cd $(1); pytest ../$$< -s --verbose --tb=short \
               --pymtl=$$(notdir $$*).py \
               $(REDIRECT_LOG) $$(notdir $$*)-py-py-test.log

$(1)-py-py-test : $$($(1)_py_py_test_logs)

py_py_test_targets += $$($(1)_py_py_test_logs)

$(1)-py-py-test-clean :
	rm -rf $$($(1)_py_py_test_logs)

py_py_test_clean_targets += $(1)-py-py-test-clean

#-------------------------------------------------------------------------
# All
#-------------------------------------------------------------------------

#$(1)-analyze : $(1)-sv-iv-test $(1)-sv-vr-test $(1)-py-py-test
# 	@$$(ECHO) Analyzing verilog + iverilog results 
# 	$$(QUIET) $$(scripts_dir)/sv-iv-analyze $(1)
# 	$$(QUIET) $$(scripts_dir)/sv-vr-analyze $(1)
# 	$$(QUIET) $$(scripts_dir)/py-py-analyze $(1)

# remove verilog/verilator for now

$(1)-analyze : $(1)-sv-iv-test $$(1)-py-py-test
	@$$(ECHO) Analyzing verilog + iverilog results 
	$$(QUIET) $$(scripts_dir)/sv-iv-analyze $(1)
	$$(QUIET) $$(scripts_dir)/py-py-analyze $(1)

#-------------------------------------------------------------------------
# Clean up
#-------------------------------------------------------------------------

$(1)-clean :
	rm -rf $(1)

# Add top-level to junk

junk += $(1)

# Phony targets

.PHONY : $(1)-sv-generate
.PHONY : $(1)-sv-iv-test
.PHONY : $(1)-sv-iv-test-clean
.PHONY : $(1)-sv-vr-test
.PHONY : $(1)-sv-vr-test-clean

.PHONY : $(1)-py-generate
.PHONY : $(1)-py-py-test
.PHONY : $(1)-py-py-test-clean

endef

$(foreach problem, $(problems), \
   $(eval $(call problem_template,$(problem))))

#-------------------------------------------------------------------------
# Top level targets
#-------------------------------------------------------------------------

sv-generate       : $(sv_generate_targets)
sv-generate-clean : $(sv_generate_clean_targets)

sv-iv-test        : $(sv_iv_test_targets)
sv-iv-test-clean  : $(sv_iv_test_clean_targets)

# sv-vr-test        : $(sv_vr_test_targets)
# sv-vr-test-clean  : $(sv_vr_test_clean_targets)

py-generate       : $(py_generate_targets)
py-generate-clean : $(py_generate_clean_targets)

py-py-test        : $(py_py_test_targets)
py-py-test-clean  : $(py_py_test_clean_targets)

sv-iv-analyze : $(sv_iv_test_targets)
	@$(ECHO) Analyzing verilog + iverilog results 
	$(QUIET) $(scripts_dir)/sv-iv-analyze \
             --csv=sv-iv-summary.csv $(problems) | tee sv-iv-summary.txt

# sv-vr-analyze : $(sv_vr_test_targets)
#  	@$(ECHO) Analyzing verilog + pymtl/verilator results 
#  	$(QUIET) $(scripts_dir)/sv-vr-analyze \
#              --csv=sv-vr-summary.csv $(problems) | tee sv-vr-summary.txt

py-py-analyze : $(py_py_test_targets)
	@$(ECHO) Analyzing pymtl + pymtl results 
	$(QUIET) $(scripts_dir)/py-py-analyze \
             --csv=py-py-summary.csv $(problems) | tee py-py-summary.txt

junk += sv-iv-summary.txt sv-iv-summary.csv
junk += sv-vr-summary.txt sv-vr-summary.csv
junk += py-py-summary.txt py-py-summary.csv

#-------------------------------------------------------------------------
# pregen
#-------------------------------------------------------------------------
# Save the generated code and logs so that we can rerun experiments
# without having to regenerate all of the generated code with an LLM.
# We use the special $(file make function because the number of files
# can be so large that it might exceed the command line limit.

pregen_dir := ../../pymtl-eval-pregen

extra_pregen_files = \
  problems.mk \
  samples.mk \
  sv-iv-summary.txt \
  sv-iv-summary.csv \
  sv-vr-summary.txt \
  sv-vr-summary.csv \
  py-py-summary.txt \
  py-py-summary.csv \

ifneq ($(pregen_dir),NOT_ENABLED)
pregen: $(sv_samples)
	$(file >  files-to-copy.txt, $(pregen_files))
	$(file >> files-to-copy.txt, $(extra_pregen_files))
	sed -i.bak -e 's/ \+/\n/g' files-to-copy.txt
	rsync --files-from=files-to-copy.txt . \
    $(pregen_dir)/$(shell date '+%Y-%m-%d-%H-%M')
	rm files-to-copy.txt files-to-copy.txt.bak
else
pregen:
	@echo "ERROR: pregen directory was not set with configure"
endif

#-------------------------------------------------------------------------
# configure information
#-------------------------------------------------------------------------

dist_junk += \
  config.status Makefile config.log \

#-------------------------------------------------------------------------
# Default
#-------------------------------------------------------------------------

# all : sv-iv-analyze sv-vr-analyze py-py-analyze
#  	$(scripts_dir)/collect-summaries

all : sv-iv-analyze py-py-analyze
	$(scripts_dir)/collect-summaries

.PHONY : all

#-------------------------------------------------------------------------
# Makefile debugging
#-------------------------------------------------------------------------
# This handy rule will display the contents of any make variable by
# using the target debug-<varname>. So for example, make debug-junk will
# display the contents of the junk variable.

debug-% :
	@echo $* = $($*)

#-------------------------------------------------------------------------
# Clean up junk
#-------------------------------------------------------------------------

clean :
	rm -rf *~ \#* wave.vcd $(junk)

distclean :
	rm -rf *~ \#* wave.vcd $(junk) $(dist_junk)

.PHONY : clean

