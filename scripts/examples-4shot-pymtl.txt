
Question:
Implement a hardware module named TopModule with the following interface.
All input and output ports are one bit unless otherwise specified.

 - input  in0
 - input  in1
 - output out

The module should implement an XOR gate.

Enclose your code with <CODE> and </CODE>. Only output the code snippet
and do NOT output anything else.

Answer:
<CODE>
from pymtl3 import *

class TopModule( Component ):

  def construct( s ):

    # Port-based interface

    s.in0 = InPort ()
    s.in1 = InPort ()
    s.out = OutPort()

    # Combinational logic

    @update
    def block1():
      s.out @= s.in0 ^ s.in1
</CODE>

Question:
Implement a hardware module named TopModule with the following interface.
All input and output ports are one bit unless otherwise specified.

 - input  clk
 - input  reset
 - input  in_ (8 bits)
 - output out (8 bits)

The module should implement an 8-bit registered incrementer with an
active-high synchronous reset. The 8-bit input is first registered and
then incremented by one on the next cycle. The internal state should be
reset to zero when the reset input is one. Assume all values are encoded
as two's complement binary numbers. Assume all sequential logic is
triggered on the positive edge of the clock.

Enclose your code with <CODE> and </CODE>. Only output the code snippet
and do NOT output anything else.

Answer:
<CODE>
from pymtl3 import *

class TopModule( Component ):

  def construct( s ):

    # Port-based interface

    s.in_ = InPort ( Bits8 )
    s.out = OutPort( Bits8 )

    # Sequential logic

    s.reg_out = Wire( Bits8 )

    @update_ff
    def block1():
      if s.reset:
        s.reg_out <<= 0
      else:
        s.reg_out <<= s.in_

    # Combinational logic

    s.temp_wire = Wire( Bits8 )

    @update
    def block2():
      s.temp_wire @= s.reg_out + 1

    # Structural connections

    s.out //= s.temp_wire
</CODE>

Question:
Implement a hardware module named TopModule with the following interface.
All input and output ports are one bit unless otherwise specified.

 - parameter nbits
 - input     clk
 - input     reset
 - input     in_ (nbits)
 - output    out (nbits)

The module should implement an N-bit registered incrementer with an
active-high synchronous reset. The bitwidth is specified by the parameter
nbits. The N-bit input is first registered and then incremented by one on
the next cycle. The internal state should be reset to zero when the reset
input is one. Assume all values are encoded as two's complement binary
numbers. Assume all sequential logic is triggered on the positive edge of
the clock.

Enclose your code with <CODE> and </CODE>. Only output the code snippet
and do NOT output anything else.

Answer:
<CODE>
from pymtl3 import *

class TopModule( Component ):

  def construct( s, nbits ):

    # Port-based interface

    s.in_ = InPort ( nbits )
    s.out = OutPort( nbits )

    # Sequential logic

    s.reg_out = Wire( nbits )

    @update_ff
    def block1():
      if s.reset:
        s.reg_out <<= 0
      else:
        s.reg_out <<= s.in_

    # Combinational logic

    s.temp_wire = Wire( nbits )

    @update
    def block2():
      s.temp_wire @= s.reg_out + 1

    # Structural connections

    s.out //= s.temp_wire
</CODE>

Question:
Implement a hardware module named TopModule with the following interface.
All input and output ports are one bit unless otherwise specified.

 - input  clk
 - input  reset
 - input  in_
 - output out

The module should implement a finite-state machine that takes as input a
serial bit stream and outputs a one whenever the bit stream contains two
consecutive one's. The output is one on the cycle _after_ there are two
consecutive one's.

Assume all sequential logic is triggered on the positive edge of the
clock. The reset input is active high synchronous and should reset the
finite-state machine to an appropriate initial state.

Enclose your code with <CODE> and </CODE>. Only output the code snippet
and do NOT output anything else.

Answer:
<CODE>
from pymtl3 import *

class TopModule( Component ):

  def construct( s ):

    # Port-based interface

    s.in_ = InPort ()
    s.out = OutPort()

    # State constants

    STATE_A = 0
    STATE_B = 1
    STATE_C = 2

    # State register

    s.state      = Wire(2)
    s.state_next = Wire(2)

    @update_ff
    def block1():
      if s.reset:
        s.state <<= STATE_A
      else:
        s.state <<= s.state_next

    # Next state combinational logic

    @update
    def block2():
      s.state_next @= s.state

      if s.state == STATE_A:
        if s.in_:
          s.state_next @= STATE_B
        else:
          s.state_next @= STATE_A

      elif s.state == STATE_B:
        if s.in_:
          s.state_next @= STATE_C
        else:
          s.state_next @= STATE_A

      elif s.state == STATE_C:
        if s.in_:
          s.state_next @= STATE_C
        else:
          s.state_next @= STATE_A

    # Output combinational logic

    @update
    def block3():
      s.out @= 0
      if   s.state == STATE_A: s.out @= 0
      elif s.state == STATE_B: s.out @= 0
      elif s.state == STATE_C: s.out @= 1
</CODE>
